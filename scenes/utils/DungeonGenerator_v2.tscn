[gd_scene load_steps=3 format=2]

[ext_resource path="res://scenes/utils/RoomsReader_v2.tscn" type="PackedScene" id=1]

[sub_resource type="GDScript" id=1]
script/source = "extends Node

onready var game = get_parent().get_parent()
onready var roomsReader = get_node(\"RoomsReader_v2\")
onready var dungeon = game.dungeon as TileMap

# Door: [position:Vector2, direction:String]
var waitingDoors:Array = []
var validatedDoors:Array = []
var array:Array = []
var arrayFullness = 0

func newFloor():
	dungeon = game.dungeon as TileMap
	var retries = 0
	generate()
	while !isFloorFull():
		generate()
		retries += 1
	print(\"Generated after \", retries, \" retires.\")

func generate():
	if !roomsReader.isInitialized:
		roomsReader.read()
	waitingDoors = []
	validatedDoors = []
	arrayFullness = 0
	array = []
	for i in range(GLOBAL.FLOOR_SIZE_X):
		array.append([])
		for _j in range(GLOBAL.FLOOR_SIZE_Y):
			array[i].append(-1)
	# Place first room
	var x = randi() % (GLOBAL.FLOOR_SIZE_X-16) + 8
	var y = randi() % (GLOBAL.FLOOR_SIZE_Y-16) + 8
	var roomId = randi() % roomsReader.roomsList.size()
	while !isRoomFits(roomId, Vector2(x, y)):
		x = randi() % (GLOBAL.FLOOR_SIZE_X-16) + 8
		y = randi() % (GLOBAL.FLOOR_SIZE_Y-16) + 8
		roomId = randi() % roomsReader.roomsList.size()
	placeFirstRoom(roomId, Vector2(x, y))
	# Until floor is full:
	while (!waitingDoors.empty()):
		# Take a door from list
		var doorIndex = randi() % waitingDoors.size()
		var door = waitingDoors[doorIndex]
		# Take a random room, try to place it
		roomId = randi() % roomsReader.roomsList.size()
		# If it fits place it otherwise test another one
		var roomDoorIndex = getRoomOppositeDoor(roomId, door[1])
		if (roomDoorIndex == -1):
			continue
		var roomDoor = roomsReader.doorsList[roomId][roomDoorIndex]
		var position = door[0] - roomDoor[0]
		var retries = roomsReader.roomsList.size()
		var placeRoom = false
		while (!placeRoom and retries > 0):
			roomId = (roomId + 1) % roomsReader.roomsList.size()
			# If it fits place it otherwise test another one
			roomDoorIndex = getRoomOppositeDoor(roomId, door[1])
			if (roomDoorIndex == -1):
				retries -= 1
				continue
			roomDoor = roomsReader.doorsList[roomId][roomDoorIndex]
			position = door[0] - roomDoor[0]
			if isRoomFits(roomId, position):
				placeRoom = true
			retries -= 1
		if placeRoom:
			placeRoom(roomId, position, roomDoorIndex)
			# Validate door
			validatedDoors.append(door[0])
		# Remove the door from list
		waitingDoors.remove(doorIndex)
	drawFloor()

func drawFloor():
	dungeon.clear()
	for i in range(GLOBAL.FLOOR_SIZE_X):
		for j in range(GLOBAL.FLOOR_SIZE_Y):
			if array[i][j] == -1:
				dungeon.set_cell(i, j, 1)
			else:
				dungeon.set_cell(i, j, array[i][j])
	for door in validatedDoors:
		dungeon.set_cell(door.x, door.y, 2)
	dungeon.update_bitmask_region()
	for cell in dungeon.get_used_cells_by_id(2):
		dungeon.set_cellv(cell, 2, false, false, false, Vector2(0,1))

func getRoomOppositeDoor(roomId, doorDirection):
	var resultList = []
	var count = 0
	for d in roomsReader.doorsList[roomId]:
		if isDoorsOpposites(d[1], doorDirection):
			resultList.append(count) 
		count += 1
	if resultList.empty():
		return -1
	var resultIndex = randi() % resultList.size()
	return resultList[resultIndex]

func isRoomFits(roomId, position):
	for c in roomsReader.roomsList[roomId]:
		var p = c[0] + position
		if (p.x < 0 or p.y < 0):
			return false
		if (p.x >= GLOBAL.FLOOR_SIZE_X or p.y >= GLOBAL.FLOOR_SIZE_Y):
			return false
		if array[p.x][p.y] != -1:
			return false
	return true

func isFloorFull():
	return arrayFullness > GLOBAL.FULLNESS_THRESHOLD * (GLOBAL.FLOOR_SIZE_X * GLOBAL.FLOOR_SIZE_Y)

func placeFirstRoom(roomId, position):
	for c in roomsReader.roomsList[roomId]:
		if (c[1] == 1):
			continue
		var p = c[0] + position
		array[p.x][p.y] = c[1]
		arrayFullness += 1
	for d in roomsReader.doorsList[roomId]:
		waitingDoors.append([d[0] + position, d[1]])

func placeRoom(roomId, position, roomDoorIndex):
	for c in roomsReader.roomsList[roomId]:
		if (c[1] == 1):
			continue
		var p = c[0] + position
		array[p.x][p.y] = c[1]
		arrayFullness += 1
	var count = 0
	for d in roomsReader.doorsList[roomId]:
		if count != roomDoorIndex:
			waitingDoors.append([d[0] + position, d[1]])
		count += 1

func isDoorsOpposites(a, b):
	match a:
		\"N\": return b == \"S\"
		\"E\": return b == \"W\"
		\"S\": return b == \"N\"
		\"W\": return b == \"E\"
	return false
"

[node name="DungeonGenerator_v2" type="Node"]
script = SubResource( 1 )

[node name="RoomsReader_v2" parent="." instance=ExtResource( 1 )]
visible = false
